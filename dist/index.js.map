{"version":3,"sources":["../src/ProcessorWrapper.ts","../src/transformers/BackgroundTransformer.ts","../src/transformers/VideoTransformer.ts","../src/transformers/RVMTransformer.ts","../src/transformers/rvm.ts","../src/index.ts"],"names":["tf","squeeze","mul","cast","tensor","imageBitmap","maskToBitmap","BackgroundProcessor","RVMBackgroundProcessor"],"mappings":"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","sourcesContent":["import type { ProcessorOptions, Track, TrackProcessor } from 'livekit-client';\nimport { TrackTransformer } from './transformers';\n\nexport default class ProcessorWrapper<TransformerOptions extends Record<string, unknown>>\n  implements TrackProcessor<Track.Kind> {\n  static get isSupported() {\n    return (\n      typeof MediaStreamTrackGenerator !== 'undefined' &&\n      typeof MediaStreamTrackProcessor !== 'undefined'\n    );\n  }\n\n  name: string;\n\n  source?: MediaStreamVideoTrack;\n\n  sourceSettings?: MediaTrackSettings;\n\n  processor?: MediaStreamTrackProcessor<VideoFrame>;\n\n  trackGenerator?: MediaStreamTrackGenerator<VideoFrame>;\n\n  canvas?: OffscreenCanvas;\n\n  sourceDummy?: HTMLMediaElement;\n\n  processedTrack?: MediaStreamTrack;\n\n  transformer: TrackTransformer<TransformerOptions>;\n\n  constructor(transformer: TrackTransformer<TransformerOptions>, name: string) {\n    this.name = name;\n    this.transformer = transformer;\n    this.transformer.restart;\n  }\n\n  private async setup(opts: ProcessorOptions<Track.Kind>) {\n    this.source = opts.track as MediaStreamVideoTrack;\n    const origConstraints = this.source.getConstraints();\n    await this.source.applyConstraints({\n      ...origConstraints,\n      // @ts-expect-error when a mediastream track is resized and/or cropped, the `VideoFrame` will have a coded height/width of the original video size\n      // this leads to a shift of the underlying video as the frame itself is being rendered with the coded size\n      // but image segmentation is based on the display dimensions (-> the cropped version)\n      // in order to prevent this, we force the resize mode to \"none\"\n      resizeMode: 'none',\n    });\n    this.sourceSettings = this.source.getSettings();\n    this.sourceDummy = opts.element;\n    if (this.sourceDummy instanceof HTMLVideoElement) {\n      this.sourceDummy.height = this.sourceSettings.height ?? 300;\n      this.sourceDummy.width = this.sourceSettings.width ?? 300;\n    }\n    if (!(this.sourceDummy instanceof HTMLVideoElement)) {\n      throw TypeError('Currently only video transformers are supported');\n    }\n    // TODO explore if we can do all the processing work in a webworker\n    this.processor = new MediaStreamTrackProcessor({ track: this.source });\n\n    this.trackGenerator = new MediaStreamTrackGenerator({\n      kind: 'video',\n      signalTarget: this.source,\n    });\n\n    this.canvas = new OffscreenCanvas(\n      this.sourceSettings.width ?? 300,\n      this.sourceSettings.height ?? 300,\n    );\n\n  }\n\n  async init(opts: ProcessorOptions<Track.Kind>) {\n    await this.setup(opts);\n    if (!this.canvas || !this.processor || !this.trackGenerator) {\n      throw new TypeError('Expected both canvas and processor to be defined after setup');\n    }\n\n    let readableStream = this.processor.readable;\n\n    await this.transformer.init({\n      outputCanvas: this.canvas,\n      inputElement: this.sourceDummy as HTMLVideoElement,\n    });\n    readableStream = readableStream.pipeThrough(this.transformer!.transformer!);\n\n    readableStream\n      .pipeTo(this.trackGenerator.writable)\n      .catch((e) => console.error('error when trying to pipe', e))\n      .finally(() => this.destroy());\n    this.processedTrack = this.trackGenerator as MediaStreamVideoTrack;\n  }\n\n  async restart(opts: ProcessorOptions<Track.Kind>) {\n    await this.destroy();\n    return this.init(opts);\n  }\n\n  async restartTransformer(...options: Parameters<(typeof this.transformer)['restart']>) {\n    // @ts-ignore unclear why the restart method only accepts VideoTransformerInitOptions instead of either those or AudioTransformerInitOptions\n    this.transformer.restart(options[0]);\n  }\n\n  async updateTransformerOptions(...options: Parameters<(typeof this.transformer)['update']>) {\n    this.transformer.update(options[0]);\n  }\n\n  async destroy() {\n    await this.transformer.destroy();\n    this.trackGenerator?.stop();\n  }\n}\n","import * as vision from '@mediapipe/tasks-vision';\n\n//import { dependencies } from '../../package.json';\nimport VideoTransformer from './VideoTransformer';\nimport { VideoTransformerInitOptions } from './types';\n\nexport type SegmenterOptions = Partial<vision.ImageSegmenterOptions['baseOptions']>;\n\nexport type BackgroundOptions = {\n  blurRadius?: number;\n  imagePath?: string;\n  /** cannot be updated through the `update` method, needs a restart */\n  segmenterOptions?: SegmenterOptions;\n  /** cannot be updated through the `update` method, needs a restart */\n  assetPaths?: { tasksVisionFileSet?: string; modelAssetPath?: string };\n};\n\nexport default class BackgroundProcessor extends VideoTransformer<BackgroundOptions> {\n  static get isSupported() {\n    return typeof OffscreenCanvas !== 'undefined';\n  }\n\n  imageSegmenter?: vision.ImageSegmenter;\n\n  segmentationResults: vision.ImageSegmenterResult | undefined;\n\n  backgroundImage: ImageBitmap | null = null;\n\n  blurRadius?: number;\n\n  options: BackgroundOptions;\n\n  constructor(opts: BackgroundOptions) {\n    super();\n    this.options = opts;\n    this.update(opts);\n  }\n\n  async init({ outputCanvas, inputElement: inputVideo }: VideoTransformerInitOptions) {\n    await super.init({ outputCanvas, inputElement: inputVideo });\n\n    const fileSet = await vision.FilesetResolver.forVisionTasks(\n      this.options.assetPaths?.tasksVisionFileSet ??\n      `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm`,\n    );\n\n    this.imageSegmenter = await vision.ImageSegmenter.createFromOptions(fileSet, {\n      baseOptions: {\n        modelAssetPath:\n          this.options.assetPaths?.modelAssetPath ??\n          //'https://storage.googleapis.com/mediapipe-tasks/image_segmenter/selfie_segmentation.tflite',\n          \"https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_multiclass_256x256/float32/1/selfie_multiclass_256x256.tflite\",\n        // 'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_multiclass_256x256/float32/latest/selfie_multiclass_256x256.tflite',\n        //'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite?v=aljali.mediapipestudio_20230621_1811_RC00',\n        //'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite',\n        delegate: 'GPU',\n        ...this.options.segmenterOptions,\n      },\n      runningMode: 'VIDEO',\n      //outputconfidenceMasks: false,\n      outputConfidenceMasks: true,\n\n      outputCategoryMask: false,\n      //outputConfidenceMasks: true,\n    });\n\n\n\n    // Skip loading the image here if update already loaded the image below\n    if (this.options?.imagePath && !this.backgroundImage) {\n      await this.loadBackground(this.options.imagePath).catch((err) => console.error(\"Error while loading processor background image: \", err));\n    }\n  }\n\n  async destroy() {\n    await super.destroy();\n    await this.imageSegmenter?.close();\n    this.backgroundImage = null;\n  }\n\n  async loadBackground(path: string) {\n    const img = new Image();\n\n    await new Promise((resolve, reject) => {\n      img.crossOrigin = 'Anonymous';\n      img.onload = () => resolve(img);\n      img.onerror = (err) => reject(err);\n      img.src = path;\n    });\n    const imageData = await createImageBitmap(img);\n    this.backgroundImage = imageData;\n  }\n\n  async transform(frame: VideoFrame, controller: TransformStreamDefaultController<VideoFrame>) {\n    try {\n      if (this.isDisabled) {\n        controller.enqueue(frame);\n        return;\n      }\n      if (!this.canvas) {\n        throw TypeError('Canvas needs to be initialized first');\n      }\n      let startTimeMs = performance.now();\n      this.imageSegmenter?.segmentForVideo(\n        this.inputVideo!,\n        startTimeMs,\n        (result) => (this.segmentationResults = result),\n      );\n\n      if (this.blurRadius) {\n        await this.blurBackground(frame);\n      } else {\n        await this.drawVirtualBackground(frame);\n      }\n      const newFrame = new VideoFrame(this.canvas, {\n        timestamp: frame.timestamp || Date.now(),\n      });\n      controller.enqueue(newFrame);\n    } finally {\n      frame.close();\n    }\n  }\n\n  async update(opts: BackgroundOptions) {\n    this.options = opts;\n    if (opts.blurRadius) {\n      this.blurRadius = opts.blurRadius;\n    } else if (opts.imagePath) {\n      await this.loadBackground(opts.imagePath);\n    }\n  }\n\n\n\n  async drawVirtualBackground2(frame: VideoFrame) {\n    if (!this.canvas || !this.ctx || !this.segmentationResults || !this.inputVideo) return;\n    // this.ctx.save();\n    // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    if (this.segmentationResults?.categoryMask) {\n      this.ctx.filter = 'blur(4px)';\n      this.ctx.globalCompositeOperation = 'destination-atop';\n      const bitmap = await maskToBitmap(\n        this.segmentationResults.categoryMask,\n        this.segmentationResults.categoryMask.width,\n        this.segmentationResults.categoryMask.height,\n      );\n      this.ctx.drawImage(bitmap, 0, 0, this.canvas.width, this.canvas.height);\n      this.ctx.filter = 'none';\n      this.ctx.globalCompositeOperation = 'source-in';\n      if (this.backgroundImage) {\n        this.ctx.drawImage(\n          this.backgroundImage,\n          0,\n          0,\n          this.backgroundImage.width,\n          this.backgroundImage.height,\n          0,\n          0,\n          this.canvas.width,\n          this.canvas.height,\n        );\n      } else {\n        this.ctx.fillStyle = '#00FF00';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n      }\n\n      this.ctx.globalCompositeOperation = 'destination-over';\n    }\n    this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n    // this.ctx.restore();\n  }\n\n\n  async drawVirtualBackground(frame: VideoFrame) {\n    if (!this.canvas || !this.ctx || !this.segmentationResults || !this.inputVideo) return;\n    // console.log(\"drawVirtualBackground\");\n    // this.ctx.save();\n    // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    if (this.segmentationResults?.confidenceMasks) {\n      this.ctx.filter = 'blur(2px)';\n      this.ctx.globalCompositeOperation = 'destination-atop';\n      const mask = this.segmentationResults?.confidenceMasks[0];\n      if (mask && mask.height == 0) {\n        //console.log(\"mask.height == 0\");\n        return;\n      }\n      const bitmap = await maskToBitmap(mask, mask.width, mask.height);\n\n      // const bitmap = await maskToBitmap(\n      //   this.segmentationResults.confidenceMasks[0],\n      //   this.segmentationResults.confidenceMasks[0].width,\n      //   this.segmentationResults.confidenceMasks[0].height,\n      // );\n      this.ctx.drawImage(bitmap, 0, 0, this.canvas.width, this.canvas.height);\n      this.ctx.filter = 'none';\n      this.ctx.globalCompositeOperation = 'source-in';\n      if (this.backgroundImage) {\n        this.ctx.drawImage(\n          this.backgroundImage,\n          0,\n          0,\n          this.backgroundImage.width,\n          this.backgroundImage.height,\n          0,\n          0,\n          this.canvas.width,\n          this.canvas.height,\n        );\n      } else {\n        this.ctx.fillStyle = '#00FF00';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n      }\n\n      this.ctx.globalCompositeOperation = 'destination-over';\n    }\n    this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n    // this.ctx.restore();\n  }\n\n  async blurBackground(frame: VideoFrame) {\n    if (\n      !this.ctx ||\n      !this.canvas ||\n      !this.segmentationResults?.categoryMask?.canvas ||\n      !this.inputVideo\n    ) {\n      return;\n    }\n\n    this.ctx.save();\n    this.ctx.globalCompositeOperation = 'copy';\n\n    const bitmap = await maskToBitmap(\n      this.segmentationResults.categoryMask,\n      this.segmentationResults.categoryMask.width,\n      this.segmentationResults.categoryMask.height,\n    );\n\n    this.ctx.filter = 'blur(0px)';\n    this.ctx.globalCompositeOperation = 'copy';\n    this.ctx.drawImage(bitmap, 0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.filter = 'none';\n    this.ctx.globalCompositeOperation = 'source-out';\n    this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.globalCompositeOperation = 'destination-over';\n    this.ctx.filter = `blur(${this.blurRadius}px)`;\n    this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.restore();\n  }\n}\n\nfunction maskToBitmap(\n  mask: vision.MPMask,\n  videoWidth: number,\n  videoHeight: number,\n): Promise<ImageBitmap> {\n  const dataArray: Uint8ClampedArray = new Uint8ClampedArray(videoWidth * videoHeight * 4);\n  const result = mask.getAsUint8Array();\n  for (let i = 0; i < result.length; i += 1) {\n    dataArray[i * 4] = result[i];\n    dataArray[i * 4 + 1] = result[i];\n    dataArray[i * 4 + 2] = result[i];\n    dataArray[i * 4 + 3] = result[i];\n  }\n  const dataNew = new ImageData(dataArray, videoWidth, videoHeight);\n\n  return createImageBitmap(dataNew);\n}\n","import { VideoTrackTransformer, VideoTransformerInitOptions } from './types';\n\nexport default abstract class VideoTransformer<Options extends Record<string, unknown>>\n  implements VideoTrackTransformer<Options> {\n  transformer?: TransformStream;\n\n  canvas?: OffscreenCanvas;\n  //canvas?: HTMLCanvasElement;\n\n  ctx?: OffscreenCanvasRenderingContext2D;\n\n  inputVideo?: HTMLVideoElement;\n\n  protected isDisabled?: Boolean = false;\n\n  async init({\n    outputCanvas,\n    inputElement: inputVideo,\n  }: VideoTransformerInitOptions): Promise<void> {\n    if (!(inputVideo instanceof HTMLVideoElement)) {\n      throw TypeError('Video transformer needs a HTMLVideoElement as input');\n    }\n    this.transformer = new TransformStream({\n      transform: (frame, controller) => this.transform(frame, controller),\n    });\n    this.canvas = outputCanvas || null;\n    if (outputCanvas) {\n      this.ctx = this.canvas?.getContext('2d') || undefined;\n    }\n    this.inputVideo = inputVideo;\n    this.isDisabled = false;\n  }\n\n  async restart({ outputCanvas, inputElement: inputVideo }: VideoTransformerInitOptions) {\n    this.canvas = outputCanvas || null;\n    this.ctx = this.canvas.getContext('2d') || undefined;\n\n    this.inputVideo = inputVideo;\n    this.isDisabled = false;\n  }\n\n  async destroy() {\n    this.isDisabled = true;\n    this.canvas = undefined;\n    this.ctx = undefined;\n  }\n\n  abstract transform(\n    frame: VideoFrame,\n    controller: TransformStreamDefaultController<VideoFrame>,\n  ): void;\n\n  abstract update(options: Options): void;\n}\n","import * as vision from '@mediapipe/tasks-vision';\nimport * as tf from '@tensorflow/tfjs';\nimport * as rvm from './rvm';\n\n\nconst segmentationConfig: rvm.SegmentationConfig = {\n    modelPath: './rvm.json',\n    ratio: 0.3,\n    mode: 'default',\n};\nconst log = (...msg: any[]) => console.log(...msg); // eslint-disable-line no-console\n\n//import { dependencies } from '../../package.json';\nimport VideoTransformer from './VideoTransformer';\nimport { VideoTransformerInitOptions } from './types';\n\nexport type RVMSegmenterOptions = Partial<vision.ImageSegmenterOptions['baseOptions']>;\n\nexport type RVMBackgroundOptions = {\n    blurRadius?: number;\n    imagePath?: string;\n    /** cannot be updated through the `update` method, needs a restart */\n    segmenterOptions?: RVMSegmenterOptions;\n    /** cannot be updated through the `update` method, needs a restart */\n    assetPaths?: { tasksVisionFileSet?: string; modelAssetPath?: string };\n};\n\nexport default class RVMBackgroundProcessor extends VideoTransformer<RVMBackgroundOptions> {\n    static get isSupported() {\n        return typeof OffscreenCanvas !== 'undefined';\n    }\n\n    imageSegmenter?: vision.ImageSegmenter;\n\n    segmentationResults: vision.ImageSegmenterResult | undefined;\n\n    backgroundImage: ImageBitmap | null = null;\n\n    blurRadius?: number;\n\n    options: RVMBackgroundOptions;\n\n    tempCanvas: HTMLCanvasElement;\n\n    constructor(opts: RVMBackgroundOptions) {\n        super();\n        this.options = opts;\n        this.update(opts);\n        this.tempCanvas = document.createElement('canvas');\n    }\n\n\n    async init({ outputCanvas, inputElement: inputVideo }: VideoTransformerInitOptions) {\n        await super.init({ outputCanvas, inputElement: inputVideo });\n        this.tempCanvas.width = outputCanvas.width;\n        this.tempCanvas.height = outputCanvas.height;\n        await tf.setBackend('webgl');\n        await tf.ready();\n        tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true); // better tfjs performance when using webgl backend\n        await rvm.load(segmentationConfig);\n        log({ segmentationConfig });\n        log({ tf: tf.version_core, backend: tf.getBackend(), state: tf.engine().state });\n        //const numTensors = tf.engine().state.numTensors;\n\n\n        // const fileSet = await vision.FilesetResolver.forVisionTasks(\n        //     this.options.assetPaths?.tasksVisionFileSet ??\n        //     `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm`,\n        // );\n\n        // this.imageSegmenter = await vision.ImageSegmenter.createFromOptions(fileSet, {\n        //     baseOptions: {\n        //         modelAssetPath:\n        //             this.options.assetPaths?.modelAssetPath ??\n        //             // 'https://storage.googleapis.com/mediapipe-tasks/image_segmenter/selfie_segmentation.tflite',\n        //             'https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite',\n        //         delegate: 'GPU',\n        //         ...this.options.segmenterOptions,\n        //     },\n        //     runningMode: 'VIDEO',\n        //     outputCategoryMask: true,\n        //     outputConfidenceMasks: false,\n        // });\n\n        // Skip loading the image here if update already loaded the image below\n        if (this.options?.imagePath && !this.backgroundImage) {\n            await this.loadBackground(this.options.imagePath).catch((err) => console.error(\"Error while loading processor background image: \", err));\n        }\n    }\n\n    async destroy() {\n        await super.destroy();\n        //await this.imageSegmenter?.close();\n        this.backgroundImage = null;\n    }\n\n    async loadBackground(path: string) {\n        const img = new Image();\n\n        await new Promise((resolve, reject) => {\n            img.crossOrigin = 'Anonymous';\n            img.onload = () => resolve(img);\n            img.onerror = (err) => reject(err);\n            img.src = path;\n        });\n        const imageData = await createImageBitmap(img);\n        this.backgroundImage = imageData;\n    }\n\n    async transform(frame: VideoFrame, controller: TransformStreamDefaultController<VideoFrame>) {\n        try {\n            if (this.isDisabled) {\n                controller.enqueue(frame);\n                return;\n            }\n            if (!this.canvas) {\n                throw TypeError('Canvas needs to be initialized first');\n            }\n            const imageBitmap = await createImageBitmap(frame);\n            const imageTensor = tf.browser.fromPixels(imageBitmap);\n            segmentationConfig.mode = \"default\";// get segmentation mode from ui\n            segmentationConfig.ratio = 0.5; // get segmentation downsample ratio from ui\n            const rgba = await rvm.predict(imageTensor as tf.Tensor3D, segmentationConfig);\n            tf.browser.toPixels(rgba, this.tempCanvas); // draw raw output\n            //const ctx = this.canvas.getContext('2d');\n            if (this.ctx) {\n                const imageBitmap = await createImageBitmap(this.tempCanvas);\n                if (this.backgroundImage) {\n                    this.ctx.drawImage(\n                        this.backgroundImage,\n                        0,\n                        0,\n                        this.backgroundImage.width,\n                        this.backgroundImage.height,\n                        0,\n                        0,\n                        this.canvas.width,\n                        this.canvas.height,\n                    );\n                }\n                this.ctx.drawImage(imageBitmap, 0, 0);\n            }\n            tf.dispose([imageTensor, rgba]); // dispose tensors\n            //let startTimeMs = performance.now();\n            // this.imageSegmenter?.segmentForVideo(\n            //     this.inputVideo!,\n            //     startTimeMs,\n            //     (result) => (this.segmentationResults = result),\n            // );\n\n            // if (this.blurRadius) {\n            //     await this.blurBackground(frame);\n            // } else {\n            //     await this.drawVirtualBackground(frame);\n            // }\n            const newFrame = new VideoFrame(this.canvas, {\n                timestamp: frame.timestamp || Date.now(),\n            });\n            controller.enqueue(newFrame);\n        } finally {\n            frame.close();\n        }\n    }\n\n    async update(opts: RVMBackgroundOptions) {\n        this.options = opts;\n        if (opts.blurRadius) {\n            this.blurRadius = opts.blurRadius;\n        } else if (opts.imagePath) {\n            await this.loadBackground(opts.imagePath);\n        }\n    }\n\n    async drawVirtualBackground(frame: VideoFrame) {\n        //if (!this.canvas || !this.ctx || !this.segmentationResults || !this.inputVideo) return;\n        if (!this.canvas || !this.ctx) return;\n        // this.ctx.save();\n        // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // if (this.segmentationResults?.categoryMask) {\n        //     this.ctx.filter = 'blur(10px)';\n        //     this.ctx.globalCompositeOperation = 'copy';\n        //     const bitmap = await maskToBitmap(\n        //         this.segmentationResults.categoryMask,\n        //         this.segmentationResults.categoryMask.width,\n        //         this.segmentationResults.categoryMask.height,\n        //     );\n        //     this.ctx.drawImage(bitmap, 0, 0, this.canvas.width, this.canvas.height);\n        //     this.ctx.filter = 'none';\n        //     this.ctx.globalCompositeOperation = 'source-in';\n        //     if (this.backgroundImage) {\n        //         this.ctx.drawImage(\n        //             this.backgroundImage,\n        //             0,\n        //             0,\n        //             this.backgroundImage.width,\n        //             this.backgroundImage.height,\n        //             0,\n        //             0,\n        //             this.canvas.width,\n        //             this.canvas.height,\n        //         );\n        //     } else {\n        //         this.ctx.fillStyle = '#00FF00';\n        //         this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        //     }\n\n        //     this.ctx.globalCompositeOperation = 'destination-over';\n        // }\n        this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n        // this.ctx.restore();\n    }\n\n    async blurBackground(frame: VideoFrame) {\n        if (\n            !this.ctx ||\n            !this.canvas ||\n            !this.segmentationResults?.categoryMask?.canvas ||\n            !this.inputVideo\n        ) {\n            return;\n        }\n\n        this.ctx.save();\n        this.ctx.globalCompositeOperation = 'copy';\n\n        const bitmap = await maskToBitmap(\n            this.segmentationResults.categoryMask,\n            this.segmentationResults.categoryMask.width,\n            this.segmentationResults.categoryMask.height,\n        );\n\n        this.ctx.filter = 'blur(3px)';\n        this.ctx.globalCompositeOperation = 'copy';\n        this.ctx.drawImage(bitmap, 0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.filter = 'none';\n        this.ctx.globalCompositeOperation = 'source-out';\n        this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.globalCompositeOperation = 'destination-over';\n        this.ctx.filter = `blur(${this.blurRadius}px)`;\n        this.ctx.drawImage(frame, 0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.restore();\n    }\n}\n\nfunction maskToBitmap(\n    mask: vision.MPMask,\n    videoWidth: number,\n    videoHeight: number,\n): Promise<ImageBitmap> {\n    const dataArray: Uint8ClampedArray = new Uint8ClampedArray(videoWidth * videoHeight * 4);\n    const result = mask.getAsUint8Array();\n    for (let i = 0; i < result.length; i += 1) {\n        dataArray[i * 4] = result[i];\n        dataArray[i * 4 + 1] = result[i];\n        dataArray[i * 4 + 2] = result[i];\n        dataArray[i * 4 + 3] = result[i];\n    }\n    const dataNew = new ImageData(dataArray, videoWidth, videoHeight);\n\n    return createImageBitmap(dataNew);\n}\n","import * as tf from '@tensorflow/tfjs';\n\n/**\n * Segmentation mode controls values returned by `predict` method\n * - `default` returns RGBA 4-channel tensor\n * - `alpha` returns Alpha 1-channel tensor\n * - `foreground` returns RGBA internally calculated foreground states\n * - `state` returns internal recurrent states as transferred between frames\n */\nexport type SegmentationMode = 'default' | 'alpha' | 'foreground' | 'state';\n\n/**\n * RVM Segmentation Model configuration\n */\nexport type SegmentationConfig = {\n    modelPath: string,\n    ratio: number,\n    mode: SegmentationMode,\n}\n\n// internal state varaibles\nlet model: tf.GraphModel;\nconst outputNodes = ['fgr', 'pha', 'r1o', 'r2o', 'r3o', 'r4o'];\nconst t: Record<string, tf.Tensor> = {}; // contains input tensor and recurrent states\nlet ratio = 0;\n\nfunction init(config: SegmentationConfig) {\n    tf.dispose([t.r1i, t.r2i, t.r3i, t.r4i, t.downsample_ratio]);\n    t.r1i = tf.tensor(0.0);\n    t.r2i = tf.tensor(0.0);\n    t.r3i = tf.tensor(0.0);\n    t.r4i = tf.tensor(0.0);\n    ratio = config.ratio;\n    t.downsample_ratio = tf.tensor(config.ratio); // initialize downsample ratio\n}\n\n/**\n * Loads RVM graph model from location specified in `config.modelPath`\n * and initialized initial states\n *\n * @param config SegmentationConfig\n * @returns GraphModel\n */\nexport async function load(config: SegmentationConfig): Promise<tf.GraphModel> {\n    model = await tf.loadGraphModel(config.modelPath);\n    init(config);\n    return model;\n}\n\nfunction getRGBA(fgr: tf.Tensor | null, pha: tf.Tensor | null): tf.Tensor3D { // gets rgba // either fgr or pha must be present\n    const norm = (r: tf.Tensor) => tf.tidy(() => {\n        const squeeze = tf.squeeze(r, ([0]));\n        const mul = tf.mul(squeeze, 255);\n        const cast = tf.cast(mul, 'int32');\n        return cast as tf.Tensor3D;\n    });\n    const rgb = fgr\n        ? norm(fgr) // normalize and use value\n        : tf.fill([pha!.shape[1] || 0, pha!.shape[2] || 0, 3], 255, 'int32'); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    const a = pha\n        ? norm(pha) // normalize and use value\n        : tf.fill([fgr!.shape[1] || 0, fgr!.shape[2] || 0, 1], 255, 'int32'); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    const rgba = tf.concat([rgb, a], -1) as tf.Tensor3D;\n    tf.dispose([rgb, a]);\n    return rgba;\n}\n\nfunction getState(state: tf.Tensor): tf.Tensor3D { // gets internal recurrent states\n    return tf.tidy(() => {\n        const r: Record<string, tf.Tensor | tf.Tensor[]> = {};\n        r.unstack = tf.unstack(state, -1);\n        r.concat = tf.concat(r.unstack, 1);\n        r.split = tf.split(r.concat, 4, 1);\n        r.stack = tf.concat(r.split, 2);\n        r.squeeze = tf.squeeze(r.stack, [0]);\n        r.expand = tf.expandDims(r.squeeze, -1);\n        r.add = tf.add(r.expand, 1);\n        r.mul = tf.mul(r.add, 127.5);\n        r.cast = tf.cast(r.mul, 'int32');\n        r.tile = tf.tile(r.cast, [1, 1, 3]);\n        r.alpha = tf.fill([r.tile.shape[0] || 0, r.tile.shape[1] || 0, 1], 255, 'int32');\n        return tf.concat([r.tile, r.alpha], -1) as tf.Tensor3D;\n    });\n}\n/**\n * Runs model prediction based and returns processed image as tensor\n * Note that execution speed is directly related to input image resolution\n *\n * @param tensor Input tensor representing RGB image [width, height, channels = 3] where width and height can be dynamic\n * @param config Controls model post-processing and return values\n * @returns Tensor as [width, height, channels] where channels can be 4 (full RGBA) or 1(alpha-only) depending on `config`\n */\nexport async function predict(tensor: tf.Tensor, config: SegmentationConfig): Promise<tf.Tensor3D> {\n    const expand = tf.expandDims(tensor, 0);\n    t.src = tf.div(expand, 255);\n    if (ratio !== config.ratio) init(config); // reinitialize recurrent states if requested downsample ratio changed\n    const [fgr, pha, r1o, r2o, r3o, r4o] = await model.executeAsync(t, outputNodes) as tf.Tensor[]; // execute model\n    let rgba: tf.Tensor3D;\n    switch (config.mode) {\n        case 'default':\n            rgba = getRGBA(fgr, pha);\n            break;\n        case 'alpha':\n            rgba = getRGBA(null, pha);\n            break;\n        case 'foreground':\n            rgba = getRGBA(fgr, null);\n            break;\n        case 'state':\n            rgba = getState(r1o); // can view any internal recurrent state r10, r20, r3o, r4o\n            break;\n        default:\n            rgba = tf.tensor(0);\n    }\n    tf.dispose([t.src, expand, fgr, pha, t.r1i, t.r2i, t.r3i, t.r4i]);\n    [t.r1i, t.r2i, t.r3i, t.r4i] = [r1o, r2o, r3o, r4o]; // update recurrent states\n    return rgba;\n}","import ProcessorWrapper from './ProcessorWrapper';\nimport BackgroundTransformer, {\n  BackgroundOptions,\n  SegmenterOptions,\n} from './transformers/BackgroundTransformer';\n\nimport RVMBackgroundTransformer, {\n  RVMBackgroundOptions,\n  // RVMSegmenterOptions,\n} from './transformers/RVMTransformer';\n\n\n\nexport * from './transformers/types';\nexport { default as VideoTransformer } from './transformers/VideoTransformer';\nexport { ProcessorWrapper, type BackgroundOptions, type SegmenterOptions, BackgroundTransformer };\n\nexport const BackgroundBlur = (blurRadius: number = 10, segmenterOptions?: SegmenterOptions) => {\n  return BackgroundProcessor({ blurRadius, segmenterOptions }, 'background-blur');\n};\n\nexport const VirtualBackground = (imagePath: string, segmenterOptions?: SegmenterOptions) => {\n  return BackgroundProcessor({ imagePath, segmenterOptions }, 'virtual-background');\n};\n\nexport const BackgroundProcessor = (options: BackgroundOptions, name = 'background-processor') => {\n  const isProcessorSupported = ProcessorWrapper.isSupported && BackgroundTransformer.isSupported;\n  if (!isProcessorSupported) {\n    throw new Error('processor is not supported in this browser');\n  }\n  const processor = new ProcessorWrapper(new BackgroundTransformer(options), name);\n  return processor;\n};\n\nexport const RVMBackgroundProcessor = (options: RVMBackgroundOptions, name = 'background-processor') => {\n  const isProcessorSupported = ProcessorWrapper.isSupported && RVMBackgroundTransformer.isSupported;\n  if (!isProcessorSupported) {\n    throw new Error('processor is not supported in this browser');\n  }\n  const processor = new ProcessorWrapper(new RVMBackgroundTransformer(options), name);\n  return processor;\n};\n"]}